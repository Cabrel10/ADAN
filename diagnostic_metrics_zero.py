#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Diagnostic du Probl√®me #5 : M√©triques Bloqu√©es √† Z√©ro
====================================================

Ce script diagnostique pourquoi les m√©triques (win_rate, total_trades, etc.)
restent bloqu√©es √† z√©ro malgr√© l'activit√© de trading.

Probl√®mes potentiels identifi√©s :
1. Les m√©triques ne comptent que les positions FERM√âES
2. Ignorent les positions OUVERTES qui contribuent au PnL
3. Logique de calcul d√©faillante dans update_trade()
4. Diff√©rence entre trades ouverts et trades ferm√©s

Auteur: Trading Bot Team
Date: 2024
"""

import sys
import json
import time
import logging
from pathlib import Path
from collections import defaultdict
from typing import Dict, Any, List

# Ajouter le chemin du bot pour les imports
sys.path.insert(0, str(Path(__file__).parent / "bot" / "src"))

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class MetricsZeroDiagnostic:
    """Diagnostic complet du probl√®me des m√©triques √† z√©ro."""

    def __init__(self):
        self.results = {}
        self.issues_found = []

    def print_header(self, title):
        """Affiche un en-t√™te de section."""
        print(f"\n{'='*80}")
        print(f"üîç {title}")
        print(f"{'='*80}")

    def print_issue(self, issue_type, description, severity="CRITIQUE"):
        """Enregistre un probl√®me trouv√©."""
        self.issues_found.append({
            'type': issue_type,
            'description': description,
            'severity': severity
        })
        status_emoji = "üî¥" if severity == "CRITIQUE" else "üü°" if severity == "ATTENTION" else "üîµ"
        print(f"{status_emoji} [{severity}] {issue_type}: {description}")

    def analyze_metrics_system(self):
        """Analyse le syst√®me de m√©triques pour identifier les probl√®mes."""
        self.print_header("ANALYSE DU SYST√àME DE M√âTRIQUES")

        try:
            from adan_trading_bot.performance.metrics import PerformanceMetrics
            from adan_trading_bot.portfolio.portfolio_manager import PortfolioManager

            print("‚úÖ Imports r√©ussis - Modules de m√©triques disponibles")

            # Analyser la classe PerformanceMetrics
            self.analyze_performance_metrics_class()

            # Analyser l'int√©gration dans PortfolioManager
            self.analyze_portfolio_manager_integration()

        except ImportError as e:
            self.print_issue("IMPORT_ERROR", f"Impossible d'importer les modules de m√©triques: {e}")
            return False

        return True

    def analyze_performance_metrics_class(self):
        """Analyse la classe PerformanceMetrics."""
        self.print_header("ANALYSE PERFORMANCE METRICS CLASS")

        try:
            from adan_trading_bot.performance.metrics import PerformanceMetrics

            # Cr√©er une instance pour tester
            metrics = PerformanceMetrics(worker_id=0)

            print(f"üìä M√©triques initialis√©es:")
            print(f"   - trades: {len(metrics.trades)}")
            print(f"   - returns: {len(metrics.returns)}")
            print(f"   - equity_curve: {len(metrics.equity_curve)}")
            print(f"   - closed_positions: {len(metrics.closed_positions)}")

            # Tester update_trade
            test_trade = {
                'action': 'close',
                'asset': 'BTCUSDT',
                'pnl': 15.50,
                'pnl_pct': 2.5,
                'equity': 1015.50
            }

            print(f"\nüß™ Test update_trade avec: {test_trade}")
            metrics.update_trade(test_trade)

            print(f"üìà Apr√®s update_trade:")
            print(f"   - trades: {len(metrics.trades)}")
            print(f"   - returns: {len(metrics.returns)}")
            print(f"   - equity_curve: {len(metrics.equity_curve)}")

            # Tester get_metrics_summary
            summary = metrics.get_metrics_summary()
            print(f"\nüìã M√©triques calcul√©es:")
            for key, value in summary.items():
                print(f"   - {key}: {value}")

            # Identifier les probl√®mes
            if len(metrics.trades) == 0:
                self.print_issue("NO_TRADES", "Aucun trade n'est enregistr√© dans le syst√®me")

            if summary.get('win_rate', 0) == 0 and len(metrics.trades) > 0:
                self.print_issue("ZERO_WIN_RATE", "Win rate √† z√©ro malgr√© des trades existants")

        except Exception as e:
            self.print_issue("METRICS_CLASS_ERROR", f"Erreur dans PerformanceMetrics: {e}")

    def analyze_portfolio_manager_integration(self):
        """Analyse l'int√©gration des m√©triques dans PortfolioManager."""
        self.print_header("ANALYSE INT√âGRATION PORTFOLIO MANAGER")

        try:
            # Analyser le code source pour les patterns probl√©matiques
            portfolio_file = Path(__file__).parent / "bot/src/adan_trading_bot/portfolio/portfolio_manager.py"

            if not portfolio_file.exists():
                self.print_issue("FILE_NOT_FOUND", f"Fichier portfolio_manager.py introuvable: {portfolio_file}")
                return

            with open(portfolio_file, 'r', encoding='utf-8') as f:
                content = f.read()

            # Chercher les patterns probl√©matiques
            patterns_to_check = [
                ("update_trade", "Appels √† update_trade"),
                ("close_position", "M√©thodes close_position"),
                ("open_position", "M√©thodes open_position"),
                ("total_trades", "R√©f√©rences √† total_trades"),
                ("win_rate", "R√©f√©rences √† win_rate"),
                ("closed_positions", "R√©f√©rences √† closed_positions"),
            ]

            print("üîç Analyse des patterns dans portfolio_manager.py:")
            for pattern, description in patterns_to_check:
                count = content.count(pattern)
                print(f"   - {description}: {count} occurrences")

            # V√©rifier la logique update_trade
            if "update_trade" in content:
                print("\n‚úÖ update_trade trouv√© dans portfolio_manager.py")
                # Extraire les contextes d'appel
                self.extract_update_trade_contexts(content)
            else:
                self.print_issue("NO_UPDATE_TRADE", "update_trade non trouv√© dans portfolio_manager")

        except Exception as e:
            self.print_issue("INTEGRATION_ANALYSIS_ERROR", f"Erreur analyse int√©gration: {e}")

    def extract_update_trade_contexts(self, content):
        """Extrait les contextes d'appel d'update_trade."""
        lines = content.split('\n')
        update_trade_lines = []

        for i, line in enumerate(lines):
            if "update_trade" in line:
                # R√©cup√©rer le contexte (3 lignes avant et apr√®s)
                start = max(0, i-3)
                end = min(len(lines), i+4)
                context = '\n'.join([f"{j:4d}: {lines[j]}" for j in range(start, end)])
                update_trade_lines.append({
                    'line_number': i+1,
                    'line': line.strip(),
                    'context': context
                })

        print(f"\nüìù Contextes d'appel update_trade ({len(update_trade_lines)} trouv√©s):")
        for idx, call in enumerate(update_trade_lines):
            print(f"\n   Call #{idx+1} (ligne {call['line_number']}):")
            print(f"   {call['line']}")
            print(f"   Contexte:\n{call['context']}")

        # Analyser les patterns probl√©matiques
        if len(update_trade_lines) == 0:
            self.print_issue("NO_UPDATE_TRADE_CALLS", "Aucun appel √† update_trade trouv√©")
        elif len(update_trade_calls := [call for call in update_trade_lines if "'action': 'close'" in call['context']]) == 0:
            self.print_issue("NO_CLOSE_TRADES", "Aucun appel update_trade pour 'close' trouv√©")

    def analyze_trade_flow_logic(self):
        """Analyse la logique de flux des trades."""
        self.print_header("ANALYSE LOGIQUE FLUX DES TRADES")

        print("üîÑ Simulation du flux de trading:")

        # Simuler un sc√©nario de trading complet
        try:
            from adan_trading_bot.performance.metrics import PerformanceMetrics

            metrics = PerformanceMetrics(worker_id=0)
            initial_equity = 1000.0

            print(f"üí∞ Capital initial: {initial_equity}")

            # Simulation d'ouverture de position
            open_trade = {
                'action': 'open',
                'asset': 'BTCUSDT',
                'size': 0.001,
                'entry_price': 45000,
                'equity': initial_equity
            }

            print(f"\nüìà Ouverture position: {open_trade}")
            metrics.update_trade(open_trade)

            summary_after_open = metrics.get_metrics_summary()
            print(f"üìä M√©triques apr√®s ouverture:")
            print(f"   - Total trades: {len(metrics.trades)}")
            print(f"   - Win rate: {summary_after_open.get('win_rate', 0):.2f}%")

            # Simulation de fermeture position (gagnante)
            close_trade = {
                'action': 'close',
                'asset': 'BTCUSDT',
                'pnl': 25.0,
                'pnl_pct': 2.5,
                'equity': initial_equity + 25.0
            }

            print(f"\nüìâ Fermeture position (gagnante): {close_trade}")
            metrics.update_trade(close_trade)

            summary_after_close = metrics.get_metrics_summary()
            print(f"üìä M√©triques apr√®s fermeture:")
            print(f"   - Total trades: {len(metrics.trades)}")
            print(f"   - Win rate: {summary_after_close.get('win_rate', 0):.2f}%")
            print(f"   - Profit factor: {summary_after_close.get('profit_factor', 0):.2f}")

            # Analyser le probl√®me
            if summary_after_close.get('win_rate', 0) == 0:
                self.print_issue("ZERO_WIN_RATE_AFTER_WIN",
                               "Win rate reste √† z√©ro apr√®s un trade gagnant")

            if len(metrics.trades) == 0:
                self.print_issue("NO_TRADES_RECORDED",
                               "Aucun trade enregistr√© apr√®s update_trade")

        except Exception as e:
            self.print_issue("SIMULATION_ERROR", f"Erreur simulation trading: {e}")

    def analyze_metrics_calculation_logic(self):
        """Analyse la logique de calcul des m√©triques."""
        self.print_header("ANALYSE LOGIQUE CALCUL M√âTRIQUES")

        try:
            # Examiner le code source de get_metrics_summary
            metrics_file = Path(__file__).parent / "bot/src/adan_trading_bot/performance/metrics.py"

            if not metrics_file.exists():
                self.print_issue("METRICS_FILE_NOT_FOUND", f"Fichier metrics.py introuvable: {metrics_file}")
                return

            with open(metrics_file, 'r', encoding='utf-8') as f:
                content = f.read()

            # Rechercher la logique de get_metrics_summary
            if "def get_metrics_summary" in content:
                print("‚úÖ get_metrics_summary trouv√© dans metrics.py")
                self.analyze_win_rate_calculation(content)
            else:
                self.print_issue("NO_METRICS_SUMMARY", "get_metrics_summary non trouv√©")

        except Exception as e:
            self.print_issue("METRICS_LOGIC_ERROR", f"Erreur analyse logique m√©triques: {e}")

    def analyze_win_rate_calculation(self, content):
        """Analyse sp√©cifiquement le calcul du win_rate."""
        lines = content.split('\n')

        # Trouver les lignes relatives au win_rate
        win_rate_lines = []
        for i, line in enumerate(lines):
            if "win_rate" in line.lower() or "winning_trades" in line or "total_trades" in line:
                win_rate_lines.append({
                    'line_number': i+1,
                    'line': line.strip()
                })

        print(f"\nüßÆ Lignes relatives au calcul win_rate ({len(win_rate_lines)} trouv√©es):")
        for line_info in win_rate_lines:
            print(f"   {line_info['line_number']:4d}: {line_info['line']}")

        # Identifier les patterns probl√©matiques
        problematic_patterns = [
            ("if t.get('pnl', 0) > 0", "Condition gagnant bas√©e sur PnL"),
            ("len(self.trades)", "Comptage bas√© sur self.trades"),
            ("len(self.closed_positions)", "Comptage bas√© sur closed_positions"),
        ]

        print(f"\nüîç Analyse des patterns de calcul:")
        for pattern, description in problematic_patterns:
            if pattern in content:
                print(f"   ‚úÖ {description}: Pr√©sent")
            else:
                print(f"   ‚ùå {description}: Absent")
                self.print_issue("MISSING_PATTERN", f"Pattern manquant: {description}")

    def identify_root_cause(self):
        """Identifie la cause racine du probl√®me."""
        self.print_header("IDENTIFICATION CAUSE RACINE")

        print("üéØ Hypoth√®ses principales:")

        hypotheses = [
            {
                'name': "Positions ouvertes ignor√©es",
                'description': "Les m√©triques ne comptent que les positions ferm√©es",
                'likelihood': "√âLEV√âE"
            },
            {
                'name': "update_trade appel√© incorrectement",
                'description': "Les appels √† update_trade ne transmettent pas les bonnes donn√©es",
                'likelihood': "MOYENNE"
            },
            {
                'name': "Logique de calcul d√©faillante",
                'description': "La logique dans get_metrics_summary a un bug",
                'likelihood': "MOYENNE"
            },
            {
                'name': "Donn√©es PnL incorrectes",
                'description': "Les donn√©es de PnL ne sont pas correctement calcul√©es",
                'likelihood': "FAIBLE"
            }
        ]

        for hypothesis in hypotheses:
            likelihood_emoji = "üî¥" if hypothesis['likelihood'] == "√âLEV√âE" else "üü°" if hypothesis['likelihood'] == "MOYENNE" else "üü¢"
            print(f"{likelihood_emoji} [{hypothesis['likelihood']}] {hypothesis['name']}")
            print(f"    {hypothesis['description']}")

    def propose_solutions(self):
        """Propose des solutions pour r√©soudre le probl√®me."""
        self.print_header("SOLUTIONS PROPOS√âES")

        solutions = [
            {
                'priority': 1,
                'title': "Inclure positions ouvertes dans m√©triques",
                'description': "Modifier le calcul pour inclure les positions ouvertes avec leur PnL non r√©alis√©",
                'implementation': [
                    "Ajouter m√©thode calculate_unrealized_pnl()",
                    "Modifier get_metrics_summary() pour inclure positions ouvertes",
                    "Cr√©er m√©triques s√©par√©es: realized_trades vs total_positions"
                ]
            },
            {
                'priority': 2,
                'title': "Corriger logique update_trade",
                'description': "S'assurer que tous les trades (ouverts ET ferm√©s) sont correctement enregistr√©s",
                'implementation': [
                    "V√©rifier tous les appels update_trade dans portfolio_manager",
                    "Ajouter validation des donn√©es dans update_trade",
                    "Logger tous les trades pour debug"
                ]
            },
            {
                'priority': 3,
                'title': "M√©triques temps r√©el",
                'description': "Impl√©menter un syst√®me de m√©triques temps r√©el incluant positions actives",
                'implementation': [
                    "Cr√©er classe RealTimeMetrics",
                    "Mise √† jour continue des m√©triques",
                    "Dashboard temps r√©el des performances"
                ]
            }
        ]

        for solution in solutions:
            priority_emoji = "üî¥" if solution['priority'] == 1 else "üü°" if solution['priority'] == 2 else "üü¢"
            print(f"{priority_emoji} PRIORIT√â {solution['priority']}: {solution['title']}")
            print(f"    üìù {solution['description']}")
            print(f"    üõ†Ô∏è Impl√©mentation:")
            for step in solution['implementation']:
                print(f"       - {step}")
            print()

    def generate_report(self):
        """G√©n√®re un rapport complet du diagnostic."""
        self.print_header("RAPPORT FINAL")

        total_issues = len(self.issues_found)
        critical_issues = len([i for i in self.issues_found if i['severity'] == 'CRITIQUE'])

        print(f"üìä R√âSUM√â:")
        print(f"   - Total probl√®mes identifi√©s: {total_issues}")
        print(f"   - Probl√®mes critiques: {critical_issues}")
        print(f"   - Statut: {'üî¥ ACTION REQUISE' if critical_issues > 0 else 'üü° OPTIMISATION RECOMMAND√âE'}")

        if self.issues_found:
            print(f"\nüîç PROBL√àMES IDENTIFI√âS:")
            for i, issue in enumerate(self.issues_found, 1):
                severity_emoji = "üî¥" if issue['severity'] == "CRITIQUE" else "üü°" if issue['severity'] == "ATTENTION" else "üîµ"
                print(f"   {i}. {severity_emoji} {issue['type']}: {issue['description']}")

        # Sauvegarder le rapport
        report_data = {
            'timestamp': time.time(),
            'total_issues': total_issues,
            'critical_issues': critical_issues,
            'issues': self.issues_found,
            'status': 'CRITICAL' if critical_issues > 0 else 'WARNING'
        }

        report_file = Path(__file__).parent / "diagnostic_metrics_zero_report.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, indent=2, ensure_ascii=False)

        print(f"\nüíæ Rapport sauvegard√©: {report_file}")

        return critical_issues == 0

    def run_full_diagnostic(self):
        """Lance le diagnostic complet."""
        print("üöÄ DIAGNOSTIC PROBL√àME #5 - M√âTRIQUES BLOQU√âES √Ä Z√âRO")
        print("=" * 80)

        start_time = time.time()

        # √âtapes du diagnostic
        steps = [
            ("Analyse syst√®me m√©triques", self.analyze_metrics_system),
            ("Analyse logique flux trades", self.analyze_trade_flow_logic),
            ("Analyse calcul m√©triques", self.analyze_metrics_calculation_logic),
            ("Identification cause racine", self.identify_root_cause),
            ("Proposition solutions", self.propose_solutions),
            ("G√©n√©ration rapport", self.generate_report)
        ]

        success = True
        for step_name, step_func in steps:
            try:
                print(f"\nüîÑ {step_name}...")
                result = step_func()
                if result is False:
                    success = False
            except Exception as e:
                print(f"‚ùå Erreur dans {step_name}: {e}")
                success = False

        duration = time.time() - start_time

        print(f"\n‚è±Ô∏è Diagnostic termin√© en {duration:.2f}s")
        print(f"‚úÖ Statut: {'SUCC√àS' if success else 'PARTIEL'}")

        return success


def main():
    """Point d'entr√©e principal."""
    diagnostic = MetricsZeroDiagnostic()
    success = diagnostic.run_full_diagnostic()

    if success:
        print("\nüéâ Diagnostic termin√© avec succ√®s!")
        print("üìã Consultez le rapport pour les solutions recommand√©es.")
    else:
        print("\n‚ö†Ô∏è Diagnostic termin√© avec des erreurs.")
        print("üîç V√©rifiez les messages d'erreur ci-dessus.")

    return 0 if success else 1


if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)
